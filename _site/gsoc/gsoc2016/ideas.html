<!DOCTYPE html>
<html>

  <head>

    <title>Ideas page for Google Summer of Code 2016</title>
    <link rel="icon" type="image/png" href="http://localhost:4000/img/logo/logoOA_white_svg.png">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="keywords" content="foss, open source, organisations, astronomy,
    OpenAstronomy, astrophysics, GSoC, projects, members, " />
    <meta name="description" content="Where all about the combined force of different open source projects in astronomy and astrophysics takes place.
">
    <meta name="author" content="OpenAstronomy" />
    <!-- OGP -->
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Ideas page for Google Summer of Code 2016" />
    <meta property="og:description" content="Where all about the combined force of different open source projects in astronomy and astrophysics takes place.
" />
    <meta property="og:url" content="https://openastronomy.org/" />
    <meta property="og:site_name" content="OpenAstronmy" />
    <!-- OGP ends here -->
    <link rel="canonical" href="http://localhost:4000/gsoc/gsoc2016/ideas.html">

        <!-- <link href='https://fonts.googleapis.com/css?family=Fira+Sans:400,400italic,500,500italic,700' rel='stylesheet' type='text/css'> -->
    <link href="../assets/fonts/fira-sans.css" rel="stylesheet">
    <link href="/css/bootstrap/bootstrap.css" rel="stylesheet" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="/css/bootstrap/bootstrap-responsive.css" rel="stylesheet" />
    <link rel="stylesheet" type="text/css" href="/css/swc.css" />
    <link rel="stylesheet" type="text/css" href="/css/swc-bootstrap.css" />
    <link rel="stylesheet" href="/css/main.css">


    <link rel="alternate" type="application/rss+xml" title="The OpenAstronomy Blog" href="/feed.xml"/>
    <!-- <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script> -->
    <script src="../../../../assets/js/jquery-3.1.1.min.js"></script>
    <script type="text/javascript">
     // change background images from a list.
     $(document).ready(function() {
         // list of filenames endings
         var backgrounds = ['ap', 'sp'];
         var selected = backgrounds[Math.floor(Math.random() * backgrounds.length)];
         var bgpath = "/css/background_" + selected + '.jpg';
         $('body').css('background-image', 'url(' + bgpath + ')');
     });
    </script>

    

</head>


  <body>

    <header class="site-header" style="background-color: #292929;">

  


  <div class="wrapper">

      <a class="site-title" href="/">
          <img class="media-object logo" src="http://localhost:4000/img/logo/logoOA_white_svg.png" alt="OpenAstronomy" />
      </a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
          <a class="page-link" href="/gsoc/">Google Summer of Code</a>
          
        
          
        
          
          <a class="page-link" href="/members/">Members</a>
          
        
          
          <a class="page-link" href="/news.html">News and Events</a>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        

        
          <a class="page-link" href="http://openastronomy.org/Universe_OA">Contributor Blogs</a>
        
          <a class="page-link" href="http://openastronomy.org/pyastro">PyAstro Conference</a>
        
          <a class="page-link" href="https://calendar.google.com/calendar/b/1?cid=YmxoZzd0MG9zbjhscm50ZDcwOXFoZzFtaXNAZ3JvdXAuY2FsZW5kYXIuZ29vZ2xlLmNvbQ">Events Calendar</a>
        
      </div>
    </nav>

  </div>

</header>


    <div class="fixed-wrap">
    <div class="page-content">
      <div class="wrapper">
        <h1 id="ideas-page-for-gsoc-2016">Ideas page for GSoC 2016</h1>

<p>Browse ideas for the following projects:</p>

<ul>
  <li>
    <p><a href="#astropy">Astropy</a></p>
  </li>
  <li>
    <p><a href="#casacore">CasaCore</a></p>
  </li>
  <li>
    <p><a href="#ims">IMS</a></p>
  </li>
  <li>
    <p><a href="#juliaastro">JuliaAstro</a></p>
  </li>
  <li>
    <p><a href="#sunpy">SunPy</a></p>
  </li>
  <li>
    <p><a href="#yt">yt</a></p>
  </li>
</ul>

<p>For each participating project, the ideas are organized from easiest to hardest.</p>

<h1 id="astropy">Astropy</h1>

<p>If you are interested in one of the following Astropy Project ideas please see
the <a href="https://github.com/astropy/astropy/wiki/GSoC-2016-Guidelines">Astropy GSoC 2016 Guidelines</a>
for additional information that is specific to Astropy.</p>

<h3 id="implement-scheduling-capabilities-for-astroplan">Implement Scheduling capabilities for Astroplan</h3>

<p><em>Suggested Mentor(s):</em> <a href="http://github.com/eteq">Erik Tollerud</a>, <a href="https://github.com/ejeschke">Eric Jeschke</a>, <a href="https://github.com/joshwalawender">Josh Walawender</a></p>

<p><em>Difficulty:</em> Beginner to Intermediate</p>

<p><em>Astronomy knowledge needed:</em> Basic understanding of how astronomy observations work, practical experience a plus</p>

<p><em>Programming skills:</em> Python</p>

<h4 id="description">Description</h4>

<p>The <a href="http://astroplan.readthedocs.org/en/latest/">astroplan</a> affiliated package is an Astropy affiliated package that provides tools for planning observations.
One valuable feature that astroplan could provide is basic scheduling capabilities for an observing run.
Many large observatories have their own schedulers, but this package would be targeted at the needs of the typical individual or small-collaboration observing run.
While some initial efforts have occurred, this project would involve expanding those efforts into a full-fledged API and implementing both the interface and the actual scheduler(s).</p>

<h3 id="ephemerides-for-solar-system-objects-in-astropy">Ephemerides for Solar System objects in Astropy</h3>

<p><em>Suggested Mentor(s):</em> <a href="http://github.com/mhvk">Marten van Kerkwijk</a>, <a href="http://github.com/eteq">Erik Tollerud</a></p>

<p><em>Difficulty:</em> Beginner to Intermediate</p>

<p><em>Astronomy knowledge needed:</em> Some understanding of astronomical coordinate systems, basic knowledge of solar system dynamics (or ability to learn as-needed to implement the specific algorithms required)</p>

<p><em>Programming skills:</em> Python, some knowledge of C might be helpful</p>

<h4 id="description-1">Description</h4>

<p>An often-requested missing feature in Astropy is the ability to compute ephemerides: the on-sky location of Solar System objects like the planets, asteroids, or artificial satellites.  This project would involve implementing just this feature. This will likely <em>start</em> with implementing a <code class="language-plaintext highlighter-rouge">get_moon</code> function similar to the existing <code class="language-plaintext highlighter-rouge">get_sun</code> to familiarize the student with the important concepts in the <code class="language-plaintext highlighter-rouge">astropy.coordinates</code> subpackage.  The larger part of the project will likely involve using the orbital elements that the JPL Solar System dynamics group has already complied (there is already a package to read these files: <a href="https://pypi.python.org/pypi/jplephem">JPLEphem</a>), and translate those into  the Astropy coordinates framework.  The student will implement these algorithms and also collaborate with the mentors and Astropy community to develop an API to access this machinery.</p>

<h3 id="implement-public-api-for-erfa">Implement Public API for ERFA</h3>

<p><em>Suggested Mentor(s):</em> <a href="http://github.com/eteq">Erik Tollerud</a>, <a href="http://github.com/taldcroft">Tom Aldcroft</a></p>

<p><em>Difficulty:</em> Intermediate to Expert</p>

<p><em>Astronomy knowledge needed:</em> None required, but may be helpful for understanding ERFA functionality</p>

<p><em>Programming skills:</em> Python, Cython, C</p>

<h4 id="description-2">Description</h4>

<p>Some of the major functionality for Astropy uses the ERFA C library (adapted from the IAU SOFA library) as the back-end for
computational “heavy-lifting”.  Members of the community have expressed a desire to use this lower-level python wrapper
around ERFA for other purposes that may not be directly relevant for Astropy.  So this project would involve making the
necessary changes to make the ERFA python API public.  This includes:</p>

<ul>
  <li>Getting the documentation up to the astropy standard (currently it is mostly auto-generated verbatim from the C comments).</li>
  <li>Implementing a more complete test suite for the python side of the code.</li>
  <li>Possibly moving it to a separate package as part of the liberfa GitHub organization.  This would also include making the necessary
changes to ensure everything continues to work in Astropy.</li>
  <li>Any other steps necessary to ensure the resulting package (or sub-package of Astropy) is stable and relatively easy to use.</li>
</ul>

<h3 id="web-development-for-gammapy">Web development for Gammapy</h3>

<p><em>Suggested Mentor(s):</em> <a href="https://github.com/cdeil">Christoph Deil</a>, <a href="https://github.com/joleroi">Johannes King</a></p>

<p><em>Difficulty:</em> Intermediate to Expert</p>

<p><em>Astronomy knowledge needed:</em> None.</p>

<p><em>Programming skills:</em> Scientific python (Numpy, Scipy, Astropy), Web development (Python backend, Javascript frontend)</p>

<h4 id="description-3">Description</h4>

<p><a href="https://docs.gammapy.org/">Gammapy</a> is a Python package for
professional gamma-ray astronomers. We are looking for a web developer with good
Python, HTML and Javascript skills that is interested in building web pages and
apps to display and browse gamma-ray data and maybe even launch Gammapy
analyses. There’s a few different projects we’d like to see realised, depending
on your interests and skills. One option is to build a much-improved version of
<a href="http://tevcat.uchicago.edu/">TeVCat</a> (a TeV catalog browse web page), that
includes more image and catalog data and interactivity (maps that pan &amp; zoom,
search field for source name) with the general public as well as professional
gamma-ray astronomers as the target. This project would mostly be front-end
development, plus Python scripts to prepare the images and catalogs in suitable
formats. Another option is to write several small static site generator scripts
or Python web apps that let us browse the gamma-ray data and analysis results,
basically a web GUI for Gammapy. That project would mostly be Python web app
development, and you have to learn a bit more about Gammapy before GSoC starts.</p>

<h3 id="data-analysis-for-gammapy">Data analysis for Gammapy</h3>

<p><em>Suggested Mentor(s):</em> <a href="https://github.com/cdeil">Christoph Deil</a>, <a href="https://github.com/joleroi">Johannes King</a></p>

<p><em>Difficulty:</em> Intermediate to Expert</p>

<p><em>Astronomy knowledge needed:</em> Some, e.g. sky coordinates and projections.
Experience with X-ray or gamma-ray data analysis (e.g. Fermi-LAT) is a plus, but not a requirement.</p>

<p><em>Method knowledge needed:</em> Some experience in data analysis (e.g. images, regions) and statistics (e.g. Poisson noise).</p>

<p><em>Programming skills:</em> Python (including pytest and Sphinx) and scientific python (Numpy, Scipy, Astropy)</p>

<h4 id="description-4">Description</h4>

<p><a href="https://docs.gammapy.org/">Gammapy</a> is a Python package for
professional gamma-ray astronomers. We are looking for someone that’s interested
towork on a few distinct data analysis tasks, each taking a few weeks of the
GSoC total time. Gammapy is a very young project, and there’s a lot to do.
Examples of what needs to be done include implementing new algorithms (e.g.
image reprojection, source detection, region-based analysis), bringing existing
prototype algorithms to production (improve API and implementation, add tests
and docs) as well as grunt work that’s needed to go towards production quality
and a Gammapy 1.0 release this fall (e.g. set up continuous integration for
example IPython notebooks or adding more tests). To get an idea of what is going
on in Gammapy and what still needs to be done, please check out the project on
Github (https://github.com/gammapy/gammapy) and browse the documentation a bit
(or try out the examples) and if this looks interesting to you, send us an email
and let us know what your skills and interests are.</p>

<h3 id="implement-psf-photometry-for-fitting-several-overlapping-objects-at-once">Implement PSF photometry for fitting several overlapping objects at once</h3>

<p><em>Suggested Mentor(s):</em> <a href="https://github.com/hamogu">Moritz Guenther</a>, <a href="https://github.com/bsipocz">Brigitta Sipocz</a></p>

<p><em>Difficulty:</em> Intermediate to Expert</p>

<p><em>Astronomy knowledge needed:</em> basic understanding of what photometry is</p>

<p><em>Programming skills:</em> Python</p>

<h4 id="description-5">Description</h4>

<p>The <a href="http://photutils.readthedocs.org/en/latest/">photutils</a> package is an Astropy affiliated package that provides tools for photometry (measuring how bright a source is).</p>

<p>There are several ways to do photometry and the package currently implements aperture photometry (just add up all the flux in an image in some some area) and single source point-spread-function (PSF) fitting (fit a function such as a Gaussian to the image). In many situations, sources may overlap in the image, e.g. when observing a dense star cluster, so that we need to fit many functions at once. However, the simple brute-force approach “just fit a model with hundreds of parameters” if there are hundreds of stars usually fails.</p>

<p>This project includes looking at other astronomy codes to see how they tackle the problem; select, modify and improve an algorithm that fits into the astropy modelling framework; implement this in python; and, if it turns out that speed is a problem, move speed-critical parts to Cython. To verify that the new code works, we will compare it to the solutions of established PSF photometry codes.</p>

<p>See https://github.com/OpenAstronomy/openastronomy.github.io/pull/27 for a discussion of some problems and possible solutions that will be addressed in this project.</p>

<h3 id="bridge-sherpa-and-astropy-fitting">Bridge sherpa and astropy fitting</h3>

<p><em>Suggested Mentor(s):</em> D. Burke, T. Aldcroft, H. M. Guenther</p>

<p><em>Difficulty:</em> Expert or better</p>

<p><em>Astronomy knowledge needed:</em> fitting functions and statistics</p>

<p><em>Programming skills:</em> Python, C, Cython</p>

<h4 id="description-6">Description</h4>

<p>Both astropy and Sherpa (https://github.com/sherpa/sherpa/) provide modelling and fitting capabilities; however, Sherpa’s features are way
more advanced. Sherpa provides far more build-in models, a larger choice of optimizers and a real variety
of fit statistics.
Unfortunately Sherpa is less well known and for historical reasons the object-oriented user interface is less polished than the functional state-based interface.
The main goal is the bring Sherpa’s optimizers and fit statistic functions to astropy; the stretch goal is
to develop a bridge between both packages such that a user can use a astropy models completely
interchangably with Sherpa models and fitters. Sherpa models should look like astropy models to astropy
to enable situations where the model can be made out of three components (a user defined model, an astropy model
and a Sherpa model) and this is then fitted to astropy data using the Sherpa fitters.</p>

<p>This project requires the student to get proficient in two major packages (Not an easy task!), but with code written in
just a few weeks of GSoC it will give astropy users access to fitting capabilites that required many years of developer time
and that are unfeasable redevelop from scratch.</p>

<h3 id="enhancements-to-ginga-a-toolkit-for-building-scientific-image-viewers">Enhancements to Ginga, a Toolkit for Building Scientific Image Viewers</h3>

<p><em>Suggested Mentor(s):</em> <a href="https://github.com/ejeschke">Eric Jeschke</a>, <a href="https://github.com/pllim">Pey-Lian Lim</a>, <a href="https://github.com/nabobalis">Nabil Freij</a></p>

<p><em>Difficulty:</em> Beginning to Advanced, depending on project choices</p>

<p><em>Astronomy knowledge needed:</em> Some, depending on project choices</p>

<p><em>Programming skills:</em> Python and scientific python (Numpy, Scipy, Astropy), git version control</p>

<p><em>Desirable:</em> OpenCL, Javascript/web sockets, C/C++ programming, experience in image or array processing, concurrent programming, experience in using GUI toolkits, github-based workflow</p>

<h4 id="description-7">Description</h4>

<p><a href="https://ejeschke.github.io/ginga/">Ginga</a> is a toolkit for constructing scientific image viewers in Python, with an emphasis toward astronomy. Ginga is being used at a number of observatories and institutes for observation and instrument control, quick look, custom data reduction and analysis tasks. The general aim is to build upon this toolkit improving its current features and to expand this toolkit in order for scientists to be able to easily accomplish preliminary data analysis.</p>

<p>We are looking for an individual to work on a few select project areas, depending on skill level and interest. Each project area itself would form a small part of the overall GSOC project. Essentially it would be a large pick and mix but do not let this put you off. This method would allow a range of different contributions to be made the Ginga toolkit that are for your choosing.</p>

<p>Beginning-level:</p>
<ul>
  <li>Improve and expand Ginga’s unit test suite and coverage</li>
  <li>Improve documentation and tutorials, including via Jupyter notebooks and video voice-overs</li>
  <li>Improve our “native app” packaging for Mac, Unix and Windows</li>
  <li>Improving LineProfile and Slit plugins</li>
  <li>Enhance existing plugins by adding GUIs for some common tasks like configuring catalog sources, which are currently done by editing config files</li>
  <li>Add support for loading broken FITS files by [“fingerprinting” them] (https://github.com/ejeschke/ginga/issues/205)</li>
</ul>

<p>Intermediate-level:</p>
<ul>
  <li>Improve Ginga backends for web browsers (native javascript/web sockets and/or Jupyter notebooks and/or Bokeh server)</li>
  <li>Enhancements to “traditional” GUI backends (e.g. add support for gtk3, AGG support for python 3, improvements to Qt-based widgets)</li>
  <li>Graft the astropy-helpers package into Ginga</li>
  <li>Adding support for calculating approximate line-of-sight velocities</li>
  <li>Enhance existing plugins for data analysis tasks, usually featuring astropy or affiliated packages</li>
</ul>

<p>Advanced-level:</p>
<ul>
  <li>Implement an OpenCL module that leverages CPU and GPU resources for accelerating some common image processing operations (scaling, transformations, rotations) on numpy image arrays. Benchmark against current CPU based solutions.</li>
  <li>Improving IO speeds by optimizing use of astropy.fits.io/cfitsio/numpy, lazy reads, file caching hints, optimizing concurrency, etc.</li>
  <li>Adding support for a binary file format used by a very popular ground-based solar telescope and extending it to support Stokes data products</li>
</ul>

<p>If you are interested in working on any of these aspects, or want to propose some other work on Ginga, please sign in to Github and comment on <a href="https://github.com/ejeschke/ginga/issues/287">Assist the Ginga Project</a>.</p>

<h1 id="casacore">CasaCore</h1>

<h3 id="improve-python-bindings-to-casacore-measures">Improve Python bindings to CasaCore measures</h3>

<p><em>Suggested Mentor(s):</em> <a href="http://github.com/gervandiepen">Ger van Diepen</a>, <a href="https://github.com/tammojan">Tammo Jan Dijkema</a></p>

<p><em>Difficulty:</em> Intermediate</p>

<p><em>Astronomy knowledge needed:</em> Some understanding of astronomical coordinate systems and transformations</p>

<p><em>Programming skills:</em> Python, some C++</p>

<h4 id="description-8">Description</h4>

<p>CasaCore contains many features to perform astronomical coordinate transformations, for example from B1950 to J2000, or from J2000 to Azimuth-Elevation. Moreover, it can compute ephemerides, which may make it useful for many other projects. See http://casacore.github.io/casacore-notes/233
The current python binding <a href="http://casacore.github.io/python-casacore/">python-casacore</a> contains a python binding to the measures library, but this is not a very programmer friendly binding, and thus not much used.
An interface to measures exists within CasaCore that makes converting coordinates much easier. This interface was written with TaQL in mind.
This project concerns modifying the TaQL measures interface to a python measures interface, thus making casacore measures easily accessible from Python</p>

<h3 id="frequency-conversions-for-taql--python-casacore">Frequency conversions for TaQL / python-casacore</h3>

<p><em>Suggested Mentor(s):</em> <a href="http://github.com/gervandiepen">Ger van Diepen</a>, <a href="http://github.com/tammojan">Tammo Jan Dijkema</a></p>

<p><em>Difficulty:</em> Beginner / Intermediate</p>

<p><em>Astronomy knowledge needed:</em> Some understanding of use of astronomical frequencies (regarding Doppler shifts etc.)</p>

<p><em>Programming skills:</em> C++</p>

<h4 id="description-9">Description</h4>

<p>The casacore measures module contains code for converting frequencies between various reference frames (e.g. Rest frequency, Geocentric, Topocentric, Galacto centric). Having this module available in TaQL would make it much more convenient to perform these kind of conversions. Example code exists for other conversions, see e.g. http://casacore.github.io/casacore/group__MeasUDF__module.html</p>

<p>This project concerns writing such a converter for the Doppler and Frequency conversions. It will require tweaking in boost-python, but since the example code is available for other measures, it should not be too hard.</p>

<h3 id="general-python-casacore-cleanup">General python-casacore cleanup</h3>

<p><em>Suggested Mentor(s):</em> <a href="http://github.com/gijzelaerr">Gijs Molenaar</a>, <a href="http://github.com/gervandiepen">Ger van Diepen</a></p>

<p><em>Difficulty:</em> Intermediate</p>

<p><em>Astronomy knowledge needed:</em> none</p>

<p><em>Programming skills:</em> python</p>

<h4 id="description-10">Description</h4>

<p>The current <a href="http://github.com/casacore/python-casacore">python-casacore</a> code is already much improved over the previous “pyrap” implementaion. This python binding to casacore is now python 3 compatible, contains some unit tests, etc. But some work remains to be done:</p>
<ul>
  <li>Remove all compile warnings</li>
  <li>Modernise code, add missing features, maybe more ‘pythonic’.</li>
  <li>Improve test coverage (24% at the moment)</li>
</ul>

<p>This is a typical project to learn making good code.</p>

<h3 id="table-plotting-for-python-casacore">Table plotting for python-casacore</h3>

<p><em>Suggested Mentor(s):</em> <a href="http://github.com/gervandiepen">Ger van Diepen</a>, <a href="https://github.com/tammojan">Tammo Jan Dijkema</a></p>

<p><em>Difficulty:</em> Beginner</p>

<p><em>Astronomy knowledge needed:</em> Some idea about astronomical units</p>

<p><em>Programming skills:</em> Python</p>

<p>Radio interferometric data sets are almost always stored in casacore “Measurement Sets”. These can be queried through TaQL, see e.g. http://casacore.github.io/casacore-notes/199 
It would be nice to have a plotting routine in <a href="http://github.com/casacore/python-casacore">python-casacore</a> to easily plot two columns against each other, which nicely formatted axes etc (possibly using wcsaxes).</p>

<p>This would, at the very least, make a nice extension to the taql jupyter kernel underneath http://taql.astron.nl</p>

<h1 id="ims">IMS</h1>

<h3 id="solar-storms-forecasting-server">Solar Storms forecasting server</h3>

<p><em>Suggested Mentors:</em> <a href="https://bitbucket.org/aldebran/">Antonio del Mastro</a> , <a href="https://bitbucket.org/OPersian/">Olena Persianova</a></p>

<p><em>Difficulty:</em> Intermediate to Hard</p>

<p><em>Astronomy knowledge needed:</em> None beforehand, the student will be required to research relevant publications.</p>

<p><em>Programming skills:</em> advanced Python; basic Theano or TensorFlow; basic Django or Flask; experience with some ANN library, such as Keras, theanets or Lasagne.</p>

<h4 id="description-11">Description:</h4>

<p>Solar storms are responsible for disruption of satellite communication, and damage to space electronical equipments. The storms have to be taken into account also for EVA and habitat maintenance activities, as the higher levels of radiation brought by them have a detrimental effect on the crew member’s health.</p>

<p>Prediction of these storms are essential to prevent said damage. A lot of astronomical data is generated on a daily basis, and this could be used in conjunction with machine learning methods to predict solar storms.</p>

<p>In this project, the student will be required to:</p>

<ul>
  <li>Using a machine learning approach, predict the <em>duration</em> and <em>intensity</em> solar storms:
    <ul>
      <li>The student should use preferably an artificial neural networks approach (although alternatives, such as random forests, SVM, bayesian models or HMMs, can be considered).</li>
      <li>The predictions should be given with 24-48 hs in advance of a storm (depending on viability).</li>
      <li>The student should evaluate training and test data provided by IMS, or find a suitable datasaet, if the data provided is unsuitable.</li>
      <li>The student should evaluate an approach suggested by the IMS to test the model’s performance, or propose a testing procedure of his/her own.</li>
    </ul>
  </li>
  <li>Provide information on a dynamically updated web page, using preferably Django or Flask, which should at least include:
    <ul>
      <li>The real-time and historical sensor’s values; as plots, when appropriate.</li>
      <li>Useful statistics about the sensors (TBD).</li>
      <li>The model’s predictions.</li>
      <li>Useful statistics about the predictions (e.g. RMSE)</li>
    </ul>
  </li>
  <li>Incorporate the prediciton model and the web page into the <a href="https://eras.readthedocs.org/en/latest/">ERAS ecosystem</a>, which means building <a href="http://www.tango-controls.org/">Tango</a> device servers (at least one for the predictor, more if necessary).</li>
</ul>

<p>Currently, a few features are being used for the prediction of solar storms, among others:</p>

<ol>
  <li><a href="http://www.spaceweather.gc.ca/solarflux/sx-3-en.php">Radio flux</a></li>
  <li><a href="http://solarscience.msfc.nasa.gov/greenwch.shtml">Sunspot area</a></li>
  <li><a href="http://sidc.oma.be/silso/datafiles">Sunspot Number</a></li>
  <li><a href="http://www.swpc.noaa.gov/products/goes-x-ray-flux">X-ray Background Flux</a></li>
</ol>

<p>We recommend the student to research the viability of using more features in the model.</p>

<p>Some other resources to get started:</p>

<p><a href="http://www.nasa.gov/mission_pages/sunearth/spaceweather/index.html">NASA’s Solar Storm and Space Weather FAQ</a></p>

<p><a href="ftp://ftp.swpc.noaa.gov/pub/warehouse/">Space Weather Prediction Center’s Historical SWPC Products and Data Displays</a></p>

<p><strong>Note</strong>: If you are interested in this project, please apply via the <a href="https://wiki.python.org/moin/SummerOfCode/2016">Python Software Fundation</a></p>

<h1 id="juliaastro">JuliaAstro</h1>

<h3 id="image-compression-and-efficient-table-reading-in-fitsiojl">Image compression and efficient table reading in FITSIO.jl</h3>

<p><em>Suggested Mentor(s):</em> <a href="http://github.com/kbarbary">Kyle Barbary</a>, <a href="https://github.com/rgiordan">Ryan Giordan</a></p>

<p><em>Difficulty:</em> Intermediate to Expert</p>

<p><em>Astronomy knowledge needed:</em> none</p>

<p><em>Programming skills:</em> Julia, some C</p>

<h4 id="description-12">Description</h4>

<p>FITS (Flexible Image Transport System) format files are the standard
containers for imaging and tabular data in astronomy. The
<a href="https://github.com/JuliaAstro/FITSIO.jl">FITSIO.jl</a> package provides
support for reading and writing these files in Julia. It is
implemented as a high-level, yet efficent, wrapper for the C library
cfitsio. This project would involve improving the available
functionality and performance of FITSIO.jl. Some desired features,
such as I/O of compressed images, reading and writing subsets of
tables and appending to existing tables already have implementations
in cfitsio. Implementing these would involve understanding the cfitsio
API and writing wrappers in Julia using <code class="language-plaintext highlighter-rouge">ccall</code>. A more advanced
feature is fast I/O of large tables with multiple columns. No C API
exists for this – it would involve understanding memory layout of
FITS tables, pointer arithmetic and byteswapping. It will be
interesting to see whether this can be done efficiently in Julia or if
a C shim is required. Finally, benchmarks should be implemented to
ensure that FITSIO.jl performance is as good as possible.</p>

<p>For a more detailed list of features, see <a href="https://github.com/JuliaAstro/FITSIO.jl/issues/37">this
issue</a>.</p>

<h1 id="sunpy">SunPy</h1>

<h3 id="lightcurve-refactor">Lightcurve Refactor</h3>

<p><em>Suggested Mentor(s):</em> <a href="http://github.com/Cadair">Stuart Mumford</a>, <a href="https://github.com/DanRyanIrish">Dan Ryan</a>, <a href="https://github.com/aringlis">Andrew Inglis</a>, <a href="https://github.com/wafels">Jack Ireland</a></p>

<p><em>Difficulty:</em> Beginner</p>

<p><em>Astronomy knowledge needed:</em> None</p>

<p><em>Programming skills:</em> Python</p>

<h4 id="description-13">Description</h4>
<p>The <code class="language-plaintext highlighter-rouge">Lightcurve</code> class is one of the three core datatypes in SunPy, along with Map and Spectra.
<code class="language-plaintext highlighter-rouge">Lightcurve</code> is designed to read in, process and store meta data related to solar physics time series data.
Currently, <code class="language-plaintext highlighter-rouge">Lightcurve</code> uses the pandas library as its underlying data structure, however, this is subject to change in the future.</p>

<p>Much like the <code class="language-plaintext highlighter-rouge">map</code> submodule, <code class="language-plaintext highlighter-rouge">lightcurve</code> needs to be able to read in various supported data formats (such as FITS, ascii and others in the future), store their meta data and give users unified access to this metadata independently of the original source of the data.</p>

<p>As currently implemented (as of 0.6) the <code class="language-plaintext highlighter-rouge">lightcurve</code> module performs three core tasks:</p>

<ol>
  <li>Download the raw data</li>
  <li>Read this data into a pandas dataframe</li>
  <li>store the meta data obtained with the data.</li>
</ol>

<p>As of the SunPy 0.7 release the first stage will be moved out of <code class="language-plaintext highlighter-rouge">lightcurve</code> and into the <code class="language-plaintext highlighter-rouge">net</code> subpackage as part of the <a href="https://github.com/sunpy/sunpy/pull/1300"><code class="language-plaintext highlighter-rouge">UnifiedDownloader</code></a> Pull Request.
This leaves <code class="language-plaintext highlighter-rouge">lightcurve</code> in a similar position to <code class="language-plaintext highlighter-rouge">map</code> where the data acquisition is not part of the core data type and is managed separately.</p>

<p>The objective of this project is to re-implement the core of the lightcurve submodule, such that it no longer contains the code to download data from the internet. The lightcurve module should be able to open file from disk that have been downloaded using the new UnifiedDownloader submodule. The lightcurve factory must be able to read files from multiple sources some of which will be able to be auto-detcted and some which will not. The lightcurve module must also be able to combine multiple files into a single timeseries.</p>

<p><strong>Expected Outcomes</strong></p>

<p>Someone under taking this project will complete the following tasks:</p>

<ol>
  <li>Become familiar with the <code class="language-plaintext highlighter-rouge">UnifiedDownloader</code> code, if it has not been accepted into the SunPy codebase, complete the remaining tasks for this to be achieved.</li>
  <li>Write a factory class for <code class="language-plaintext highlighter-rouge">lightcurve</code> similar to the <code class="language-plaintext highlighter-rouge">sunpy.map.Map</code> class. This class will be a generic constructor for <code class="language-plaintext highlighter-rouge">lightcurve</code> allowing the user to instantiate any one of the many subclasses of <code class="language-plaintext highlighter-rouge">GenericLightcurve</code> present in <code class="language-plaintext highlighter-rouge">sunpy.lightcurve.sources</code>. The API design for the factory class is in <a href="https://github.com/sunpy/sunpy-SEP/blob/master/SEP-0007.md">SEP 7</a>.</li>
  <li>Design and develop a robust method of dealing with lightcurve meta data, which can handle joining different parts of timeseries from different files, each with their own meta data. (See <a href="https://github.com/sunpy/sunpy/issues/1122">#1122</a>)</li>
</ol>

<p>A successful proposal for this project will demonstrate that the applicant has understood the mechanism behind the <code class="language-plaintext highlighter-rouge">Map</code> factory as already implemented in SunPy and presents a timeline of what things need to change in Lightcurve to mirror the design of <code class="language-plaintext highlighter-rouge">Map</code> and follow the design for Lightcurve in <a href="https://github.com/sunpy/sunpy-SEP/blob/master/SEP-0007.md">SEP 7</a>.</p>

<h3 id="implementing-aia-response-functions-in-sunpy">Implementing AIA response functions in SunPy</h3>

<p><em>Suggested Mentor(s):</em> <a href="https://github.com/SolarDrew">Drew Leonard</a>, <a href="https://github.com/wtbarnes">Will Barnes</a></p>

<p><em>Difficulty:</em> Beginner</p>

<p><em>Astronomy knowledge needed:</em> Some knowledge of coronal emission processes would be beneficial.</p>

<p><em>Programming skills:</em> Python.</p>

<h4 id="description-14">Description</h4>

<p>The <a href="http://www.chiantidatabase.org/">CHIANTI</a> atomic physics database is a valuable resource for solar physics.
The CHIANTI database holds a large amount of information on the physical properties of different elements in different ionisation states and enables the calculation of various parameters from this information.
Using CHIANTI it is possible to calculate the spectra of various types of solar plasma (e.g., flare, quiet sun, etc.) from the observed elemental abundances and ionisation states.
These synthetic spectra are essential for calculating reponse functions of various instruments.
An instrument’s wavelength response function describes how much light emitted at a given wavelength is measured by the instrument.
Similarly, the temperature response function describes the instrument’s sensitivity to light emitted by plasma at a particular temperature.
These response functions play a vital role in correctly interpreting observations, as does proper calculation of these functions.</p>

<p>Currently, SunPy has no implementation of instrument response functions.
This project would develop the routines necessary to calculate response functions using the Python interface to the CHIANTI database, <a href="http://chiantipy.sourceforge.net/">ChiantiPy</a>.
The primary implementation of this would be to produce default wavelength and temperature response functions for the <a href="http://aia.lmsal.com/">Atmospheric Imaging Assembly</a> instrument.
A detailed discussion of the AIA response functions can be found in <a href="https://ui.adsabs.harvard.edu/#abs/2012SoPh..275...41B">Boerner et al 2012</a>.</p>

<p>Other potential applications of ChiantiPy in SunPy include:</p>

<ol>
  <li>Generalisation of the code to produce response functions using arbitrary values of physical parameters (elemental abundances, etc.).</li>
  <li>Calculation of reponse functions for other instruments.</li>
  <li>Conversion of ChiantiPy spectra objects to SunPy Spectra objects.</li>
</ol>

<p><strong>Expected Outcomes</strong>: This project would facilitate SunPy becoming independent from Solar SoftWare (SSW) for analysing AIA data, particularly with respect to inferring plasma properties such as temperature and density.</p>

<p>A successful proposal will outline a schedule for implementing at least a single set of temperature and wavelength response functions for AIA, and the response functions for arbitrary plasma conditions would be a bonus.
Familiarity with CHIANTI, ChiantiPy and SSW’s implementation of the response functions will help to properly assess how long will be required to recreate them in SunPy.</p>

<h3 id="real-time-data-access-and-visualisation-tools">Real time data access and visualisation tools</h3>

<p><em>Suggested Mentor(s):</em> <a href="http://github.com/dpshelio">David Perez-Suarez</a>, <a href="https://github.com/wafels">Jack Ireland</a></p>

<p><em>Difficulty:</em> Beginner-Intermediate</p>

<p><em>Astronomy knowledge needed:</em> none</p>

<p><em>Programming skills:</em> Python</p>

<h4 id="description-15">Description</h4>

<p>Real time data is very useful for
<a href="https://en.wikipedia.org/wiki/Space_weather">spaceweather operations</a>, SunPy
provides access to data by different virtual observatories or services (like
<code class="language-plaintext highlighter-rouge">sunpy.net.vso</code> or <code class="language-plaintext highlighter-rouge">sunpy.net.hek</code>) or by accessing to direct data archives.
<code class="language-plaintext highlighter-rouge">Fido</code> (formerly called <code class="language-plaintext highlighter-rouge">UnifiedDownloader</code>) provides a single point of access
to them all. However, this needs to be extended to
<a href="https://drive.google.com/open?id=1JizSdVKzKu_yFHXg4Bad5xcFREedcw7MhWwVto7L9kw">other data archives</a>,
and a logic implemented so depending on the time range asked it downloads the
data from the realtime archives or from the full-archive.</p>

<p>Additionally, this project should produce some visualisation tools to combine
data from different sources. Some examples are overlay of active regions on top
of solar images (like in <a href="http://www.solarmonitor.org">SolarMonitor</a>), GOES
X-ray flux with active regions number on the flares detected (like in
<a href="http://www.lmsal.com/solarsoft/last_events/">Latest Events</a>), latest features
observed available from HEK on top of a map (e.g.
<a href="http://www.lmsal.com/hek/hek_isolsearch.html">isolsearh</a>).</p>

<p>In summary, this project has two objectives:</p>

<ol>
  <li>Implementation of real time archives and logic on <code class="language-plaintext highlighter-rouge">Fido</code>.</li>
  <li>Creation of visualisation tools to represent real-time data.</li>
</ol>

<p>Familiarisation with the
<a href="https://github.com/sunpy/sunpy/tree/unidown"><code class="language-plaintext highlighter-rouge">unidown</code> branch</a> and
<a href="http://matplotlib.org/"><code class="language-plaintext highlighter-rouge">matplotlib</code></a> library will help you to create a proper
timeline on how much time will take to implement, test and document each part of
the project.</p>

<h3 id="improvements-to-the-sunpy-database">Improvements to the SunPy Database</h3>

<p><em>Suggested Mentor(s):</em> <a href="http://github.com/Cadair">Stuart Mumford</a>, <a href="http://github.com/derdon">Simon Liedtke</a>, <a href="http://github.com/ehsteve">Steven Christe</a></p>

<p><em>Difficulty:</em> Intermediate</p>

<p><em>Astronomy knowledge needed:</em> None</p>

<p><em>Programming skills:</em> Python, some database design knowledge would be helpful.</p>

<h4 id="description-16">Description</h4>

<p>The <code class="language-plaintext highlighter-rouge">database</code> module provides functionality to users to manage collections of files on disk in a way not reliant upon folder structure and file name.
The database allows users to find files on disk by either physical parameters, such as wavelength and time or properties of the instrument such as name and spacecraft.
It also allows more complex queries by enabling searches of the raw meta data associated with the files.</p>

<p>The SunPy database will also act as a proxy for some web services supported by SunPy. When used like this, the database module takes a user query, downloads the data from the web service and then stores it in the database, and then returns the query to the user. SunPy contains clients to various web services, the first and primary web service SunPy supported was the Virtual Solar Observatory (VSO), this is the web service the database was originally designed to support. Since the original development of the database module, the database has also been extended to support the HEK client.</p>

<p>The SunPy web clients, use a system named <code class="language-plaintext highlighter-rouge">attrs</code> (an abbreviation for attributes) to compose queries, this attrs system is also used by the database to perform queries on the database, with some of the attrs shared between the VSO client and the database.
Recently, a new downloader front end (originally named <code class="language-plaintext highlighter-rouge">UnifiedDownloader</code>, now affectionately known as <code class="language-plaintext highlighter-rouge">Fido</code>) has been developed, this provides a Factory Class, with which various download clients (such as the VSO) can register with, providing information about which attrs and attr values that client supports. Using this approach, the <code class="language-plaintext highlighter-rouge">Fido</code> downloader provides a single interface to the many different services SunPy supports.
The first part of this project will be to update the database module to support the new <code class="language-plaintext highlighter-rouge">Fido</code> interface, specifically by using <code class="language-plaintext highlighter-rouge">Fido</code> inside the database to retrieve data.</p>

<p>The second part of the project will be to update the caching mechanism implemented in the database module. The current caching system serialises the users VSO query and stores it as JSON, upon the user requesting another query, the query will be compared to the cache of serialised queries and if a match is found, the results from the cached query returned.
This mechanism is limiting in that if the user requests 100 records in query A and 100 records in query B, but 50 of the records requested in both queries are the same (i.e. two overlapping time windows) then the 50 records will be re-downloaded as the cache of query A will not match query B.
The updated caching system will store the records a query returns (before the data is downloaded) and then link the results of a query to the records in the database (once the data has been downloaded). Then when records are retrieved from a web service, any records that are stored in the cache table can be skipped for retrieval from the web service and returned from the records in the database.
This will allow the caching of partial queries rather than whole queries as is currently implemented.</p>

<p>This project aims to achieve the following things:</p>

<ol>
  <li>Update the current implementation of the database using the VSO attributes to use the slightly refactored <code class="language-plaintext highlighter-rouge">Fido</code> attributes and use <code class="language-plaintext highlighter-rouge">Fido</code> inside the database to download data from the VSO.</li>
  <li>Implement a new caching mechanism bases of the results of Queries with <code class="language-plaintext highlighter-rouge">Fido</code> rather than the current caching which is based upon the VSO query.</li>
</ol>

<p>A successful proposal will schedule updates to the database package in small sections, rather than in one large pull request. The work should be understood and broken down into individual sections.</p>

<p>There are various other maintenance tasks which need undertaking (https://github.com/sunpy/sunpy/labels/Database) which would be a good way for someone interested in this project to familiarise themselves with the codebase.</p>

<h3 id="gui-to-use-lct-tools">GUI to use LCT tools</h3>
<p><em>Suggested Mentor(s):</em> <a href="https://github.com/Hypnus1803">Jose Iván Campos Rozo</a> (National Astronomical Observatory, National University of Colombia), Santiago Vargas Domínguez (National Astronomical Observatory, National University of Colombia), <a href="https://github.com/dpshelio">David Pérez Suárez</a>.</p>

<p><em>Difficulty:</em> Intermediate</p>

<p><em>Astronomy knowledge needed:</em> None</p>

<p><em>Programming skills:</em> Python, basic knowledge of qt4, pyqt4, qt designer</p>

<h4 id="description-17">Description:</h4>
<p>The Local Correlation Tracking (LCT, November &amp; Simon, 1988) technique is a robust method used to study the dynamics of structures in a time series of images. By tracking pixel displacements, using a correlation window, LCT can determine proper motions and generate flow maps of horizontal velocities. This procedure is used to study the dynamics of plasma in the solar photosphere at different spatial scales, e.g the analysis of granular and supergranular convective cells, meridional flows, etc. A widget implemented in Python was developed. It generates a user-friendly graphical user interface (GUI) to control various parameters for the process of calculating flow maps of proper motions for a series of filtergrams (data cube). Our purpose is to implement this tool in Sunpy using its structure and to improve it with some more options, i.e. masks, statistics, histograms, contours and multi-plots. Although an initial version is already developed, our proposal is to focus on the efficient integration of the code in the  SunPy libraries. The code (without widget files yet) is https://github.com/Hypnus1803/flow_maps</p>

<p><em>Expected Outcomes:</em> To integate efficiently the code in SunPy libraries.</p>

<h1 id="yt">yt</h1>

<p>If you are interested in one of the yt ideas, please see the
<a href="https://bitbucket.org/yt_analysis/yt/wiki/Google%20Summer%20of%20Code%202016%20Guidelines">GSoC 2016 Guidelines</a>
on the yt bitbucket wiki.</p>

<p>All projects in this section are for <a href="https://yt-project.org">yt</a>, an analysis
and visualization environment for particle and mesh-based volumetric data. It
has readers for most astrophysical simulation codes, as well as a few nuclear
engineering simulation codes. It can handle data produced by particle-based
codes, as well data produced by codes that use various types of mesh structures,
including uniform and adaptively refined meshes as well as unstructured and
semistructured meshes. yt is able to analyze and visualize these datasets with
substantially different on-disk and in memory formats using a common language.</p>

<p>To learn more about how to use yt to interact with simulation data, take a look
at the <a href="http://yt-project.org/doc/quickstart/index.html">quickstart guide</a>, as
well as the rest of <a href="http://yt-project.org/doc">the yt documentation</a>. We also
provide <a href="http://yt-project.org/data">a listing of sample test datasets</a> that can
be loaded by yt. We use a variety of
<a href="http://yt-project.org/community.html">public communication channels</a>, including
mailing lists, IRC, and a slack channel that can be joined by anyone interested
in yt development.</p>

<p>For more information about contributing to yt, take a look at our
<a href="http://yt-project.org/docs/dev/developing/index.html">developer guide</a>. To see
discussions about past yt projects, take a look at the yt enhancement proposal
(YTEP) <a href="https://ytep.readthedocs.org">listing</a>.</p>

<h3 id="integrate-yt-plots-with-interactive-matplotlib-backends">Integrate yt plots with interactive matplotlib backends</h3>

<p><em>Suggested Mentor(s):</em> <a href="https://bitbucket.org/ngoldbaum">Nathan Goldbaum</a>,
 <a href="https://bitbucket.org/MatthewTurk/">Matthew Turk</a></p>

<p><em>Difficulty:</em> Intermediate</p>

<p><em>Knowledge needed:</em> Familiarity with matplotlib. Knowledge of matplotlib’s
 object oriented API a plus.</p>

<p><em>Programming skills:</em> Python. GUI programming.</p>

<h4 id="description-18">Description</h4>

<p>Currently, all yt plotting objects have a <code class="language-plaintext highlighter-rouge">show()</code> method that
displays <a href="https://gist.github.com/f36b29c340e8516eeae2">a version of the plot in Jupyter notebooks</a>. This works for the most
part and is relatively simple due to Jupyter’s data model. However, this
reliance on the notebook fails for users who work primarily from the command
line, either in the vanilla python interpreter or the IPython command line
application. We receive many requests from confused users who do not understand
why <code class="language-plaintext highlighter-rouge">show()</code> errors out in the regular python interpreter or appears to do
nothing in <code class="language-plaintext highlighter-rouge">IPython</code>, when they expect a GUI window to pop up when they run
<code class="language-plaintext highlighter-rouge">show()</code>.</p>

<p>This project would have a student modify yt’s plotting objects to hook into
matplotlib’s interactive backends so that plots can be optionally displayed
using a GUI plotting window. Optimally, we would also enable callbacks so that
zooming and selecting does the “right thing”, generating high resolution data
when it is available.</p>

<p>This is constrained by maintaining backward compatibility: by default yt should
not fail when generating plots on headless devices (e.g. when connecting over
SSH to a supercomputer).</p>

<p><em>Deliverables:</em></p>

<ul>
  <li>
    <p>A proof of concept demonstrating how to hook into matplotlib’s interactive
backends using the matplotlib object-oriented API, or a way to show how to
gracefully fall back to using pyplot instead of the object oriented API.</p>
  </li>
  <li>
    <p>A <a href="https://ytep.readthedocs.org">YTEP</a> describing the proposed approach for
modifying yt’s plotting infrastructure to support matplotlib’s interactive
plotting backends.</p>
  </li>
  <li>
    <p>The implementation for the YTEP submitted as a bitbucket pull request to the
main yt repository.</p>
  </li>
</ul>

<h3 id="improve-test-coverage-and-test-performance">Improve test coverage and test performance</h3>

<p><em>Suggested Mentor(s):</em> <a href="https://bitbucket.org/xarthisius">Kacper Kowalik</a>,
 <a href="https://bitbucket.org/ngoldbaum">Nathan Goldbaum</a></p>

<p><em>Difficulty:</em> Beginner to Advanced, depending on where the student takes the
 project</p>

<p><em>Knowledge needed</em>: Familiarity with the <code class="language-plaintext highlighter-rouge">nose</code> testing package.</p>

<p><em>Programming skills:</em> Python, Cython</p>

<h4 id="description-19">Description</h4>

<p>Currently yt’s test suite is split between unit tests (which take about 45
minutes to run) and answer tests, which are normally only run on a continuous
integration server. Altogether the tests only cover about a third of the yt
codebase, so much of the code in yt needs test coverage.  Additionally, the
tests take a long time to run, and we would like to reduce the test runtime
while simultaneously increasing code coverage.</p>

<p>This project could go in a number of directions:</p>

<ul>
  <li>
    <p>Implement a way to retrofit the current tests for different geometries
(e.g. cartesian, cylindrical, and spherical coordinates) and data styles
(e.g. particle data, as well as various kind of mesh data, including uniform
resolution, octree, patch AMR, and unstructured meshes). Ideally this would
allow us to test all functionality for all possible data styles. This will
require learning and improving the “Stream” frontend, which allows the
injestion of in-memory data into yt.</p>
  </li>
  <li>
    <p>Identify areas of the code that are not well tested and devise tests for
them. This will require measuring the test coverage of yt’s Python and
Cython components. The student working on this will need to gain familiarity
with untested or undertested parts of the codebase and add new
tests. Optimally the new tests will make use of new reusable infrastructure
that will be helpful for tests across the yt codebase.</p>
  </li>
  <li>
    <p>Improve volume rendering and visualization unit tests. Right now visualization
tests rely heavily on answer testing and image comparison. It would be more
flexible and easier to understand when things go wrong if the tests instead
compared with a predicted answer using some sort of simplified geometry or via
introspection.</p>
  </li>
</ul>

<p><em>Deliverables</em>:</p>

<ul>
  <li>
    <p>Develop a framework for measuring test covering in yt’s python and cython
components. Triage the reports to look for areas that are user facing and have
poor test coverage.</p>
  </li>
  <li>
    <p>Make a number of pull requests adding tests across the yt codebase.</p>
  </li>
  <li>
    <p>Modify existing testing infrastructure or develop new test infrastructure to
improve testing of yt functionality on different data types.</p>
  </li>
</ul>

<h3 id="domain-contexts-and-domain-specific-fields">Domain contexts and domain-specific fields</h3>

<p><em>Suggested Mentor(s):</em> <a href="https://bitbucket.org/brittonsmith">Britton Smith</a>,
 <a href="https://bitbucket.org/matthewturk">Matthew Turk</a></p>

<p><em>Difficulty:</em> Beginner to Intermediate</p>

<p><em>Knowledge needed</em>: Undergrad level Physics knowledge. More specific
 domain-specific knowledge of astronomy, hydrodynamics, finite-element methods,
 GIS, meteorology, geophysics, oceanography a plus</p>

<p><em>Programming skills:</em> Python</p>

<p>The original focus of yt was to analyze datasets from astrophysical
simulations.  However, use of yt has been expanding to other
scientific domains, such as nuclear physics, meteorology, and
geophysics.  Still, much of the infrastructure within yt is built upon
the assumption that the datasets being loaded are astrophysical and
hydrodynamic in nature.  This assumption informs the choice of derived
fields made available to the user as well as the default unit system.
For example, fields such as “Jeans mass” and “X-ray emissivity” in CGS
units are of little use to an earthquake simulation.</p>

<p>The goal of this project is to develop a system for domain contexts,
sets of fields and unit systems associated with specific scientific
domains.  Rather than having all fields be made available to all
datasets, each dataset is given a domain context, which specifies the
relevant fields and most meaningful unit system.  Domain contexts
could also be subclassed to provide further specificity, for example,
cosmology as a subclass of astrophysics.</p>

<p><em>Deliverables:</em></p>

<ul>
  <li>
    <p>For each of the existing frontends, identify the relevant field
plugins. Create a data structure to associate with each frontend that lists
only the relevant plugins. Take the field plugin loading machinery, which
currently just loops over all plugins, and have it only load plugins relevant
to the loaded frontend.</p>
  </li>
  <li>
    <p>With the above as an example, identify and document all of the places in the
code where the domain is assumed to be astronomy. Use this to come up with a
set of attributes that minimally describe a scientific domain, i.e., list of
field plugins, unit system, etc.</p>
  </li>
  <li>
    <p>Write up a <a href="https://ytep.readthedocs.org">YTEP</a> describing the proposed design
and ideas for implementation. Should identify an initial set of domain
contexts, sort fields into domain contexts, and sketch how frontends should
declare needed domain contexts.</p>
  </li>
  <li>
    <p>Create a domain context class with the identified attributes. Implement an
Base, astronomy, and possibly a nuclear engineering domain context and
associate it with the existing frontends.</p>
  </li>
</ul>


      </div>
    </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">
	<p class="tagline"><strong>OpenAstronomy</strong>: Combining the power of open source astrophysics projects to empower science.</p>
  <a href="https://app.element.io/#/room/#openastronomy:openastronomy.org" target="_blank">
      <span class="icon-image  icon--github">
          <svg viewBox="0 0 40 40" height="100%">
              <path fill="#f9f9f9" d="M30,12V8h-5.004l1-8h-4l-1,8h-7.998l1-8h-4l-1,8H2v4h6.498L7.5,20H2v4h5l-1,8h4l1-8h8l-1.002,8H22l1-8h7v-4h-6.5l0.996-8H30z M19.5,20h-8l0.998-8h7.998L19.5,20z"/>
          </svg>
      </span>
  </a>
  <a href="https://groups.google.com/forum/#!forum/openastronomy" target="_blank">
      <span style="color:white!important;" >
          <span class="icon-white  icon-envelope" style="color:blue!important;">
	  </span>
      </span>

  </a>
  <a href="https://community.openastronomy.org">
      <img src="/img/icons/discourse_icon.png" alt="OpenAstronomy on Discourse">
  </a>
  <a rel="me" href="https://twitter.com/Open_Astronomy">
            <span class="icon-image  icon--github">
                <svg viewBox="0 0 16 16">
                    <path fill="#f9f9f9" d="M5.026 15c6.038 0 9.341-5.003 9.341-9.334 0-.14 0-.282-.006-.422A6.685 6.685 0 0 0 16 3.542a6.658 6.658 0 0 1-1.889.518 3.301 3.301 0 0 0 1.447-1.817 6.533 6.533 0 0 1-2.087.793A3.286 3.286 0 0 0 7.875 6.03a9.325 9.325 0 0 1-6.767-3.429 3.289 3.289 0 0 0 1.018 4.382A3.323 3.323 0 0 1 .64 6.575v.045a3.288 3.288 0 0 0 2.632 3.218 3.203 3.203 0 0 1-.865.115 3.23 3.23 0 0 1-.614-.057 3.283 3.283 0 0 0 3.067 2.277A6.588 6.588 0 0 1 .78 13.58a6.32 6.32 0 0 1-.78-.045A9.344 9.344 0 0 0 5.026 15z"/>
                </svg>
            </span>
  </a>
  <a rel="me" href="https://astrodon.social/@OpenAstronomy">
            <span class="icon-image  icon--github">
                <svg viewBox="0 0 16 16">
                    <path fill="#f9f9f9" d="M11.19 12.195c2.016-.24 3.77-1.475 3.99-2.603.348-1.778.32-4.339.32-4.339 0-3.47-2.286-4.488-2.286-4.488C12.062.238 10.083.017 8.027 0h-.05C5.92.017 3.942.238 2.79.765c0 0-2.285 1.017-2.285 4.488l-.002.662c-.004.64-.007 1.35.011 2.091.083 3.394.626 6.74 3.78 7.57 1.454.383 2.703.463 3.709.408 1.823-.1 2.847-.647 2.847-.647l-.06-1.317s-1.303.41-2.767.36c-1.45-.05-2.98-.156-3.215-1.928a3.614 3.614 0 0 1-.033-.496s1.424.346 3.228.428c1.103.05 2.137-.064 3.188-.189zm1.613-2.47H11.13v-4.08c0-.859-.364-1.295-1.091-1.295-.804 0-1.207.517-1.207 1.541v2.233H7.168V5.89c0-1.024-.403-1.541-1.207-1.541-.727 0-1.091.436-1.091 1.296v4.079H3.197V5.522c0-.859.22-1.541.66-2.046.456-.505 1.052-.764 1.793-.764.856 0 1.504.328 1.933.983L8 4.39l.417-.695c.429-.655 1.077-.983 1.934-.983.74 0 1.336.259 1.791.764.442.505.661 1.187.661 2.046v4.203z"/>
                </svg>
            </span>
  </a>

  <a href="/feed.xml">
      <span class="icon-image  icon--github">
          <svg viewBox="0 0 16 16">
              <path fill="#f9f9f9" d="M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z M5.5 12a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm-3-8.5a1 1 0 0 1 1-1c5.523 0 10 4.477 10 10a1 1 0 1 1-2 0 8 8 0 0 0-8-8 1 1 0 0 1-1-1zm0 4a1 1 0 0 1 1-1 6 6 0 0 1 6 6 1 1 0 1 1-2 0 4 4 0 0 0-4-4 1 1 0 0 1-1-1z"/>
          </svg>
  </a>
  <a href="https://github.com/openastronomy">
      <span class="icon-image  icon--github">
          <svg viewBox="0 0 16 16">
              <path fill="#f9f9f9" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
          </svg>
      </span>
      <!-- <span class="username">OpenAstronomy</span> -->
  </a>
  </div>

</footer>


  </body>

</html>
